import { getChecksumFromArrayBuffer } from './helpers.js'

const defaultOptions = {
  payload: null,
  maxPacketSize: 1470,
  header: {
    version: 0,
    downstreamFlag: true,
    compressedFlag: false,
    type: 1
  },
  message: {
    nodeId: 1,
    session: 1
    // frame: 230, (autogenerated)
    // fragment: 0 (autogenerated)
  },
  firstFragment: {
    // byteLength: 1, (autogenerated)
    // checksum: 234 (autogenerated)
  }
}

let frameCount = 0

const GENERAL_HEADER = 8
const MESSAGE_HEADER = 32
const FIRST_FRAME_HEADER = 24

/**
 * Converts a decimal into it's binary counterpart respecting bits amount
 * Ex. Input (2,3) will return "010"
 * @param dec
 * @param bits
 * @returns {*}
 */
function dec2bin(dec, bits = 1) {
  let bin = (dec >>> 0).toString(2)
  if (bin.length < bits) {
    for (let i = bin.length; i < bits; i++) {
      bin = '0' + bin
    }
  }
  return bin
}

/**
 * Returns the first header byte for a frame
 * @param options
 * @returns {number}
 */
const getHeader = options => {
  const version = dec2bin(0, 3)
  const downstreamFlag = dec2bin(options.header.downstreamFlag)
  const compressedFlag = dec2bin(options.header.compressedFlag)
  const type = dec2bin(options.header.type, 3)
  const bin = version + downstreamFlag + compressedFlag + type
  return parseInt(bin, 2)
}

/**
 * Chunks a given array buffer into several array Buffers with a maximum length of len
 * @param arr
 * @param len
 * @returns {[]}
 */
const chunkArrayBuffer = (arr, len) => {
  var chunks = [],
    i = 0,
    n = arr.byteLength

  while (i < n) {
    chunks.push(arr.slice(i, (i += len)))
  }

  return chunks
}

/**
 * Returns an Array of ArrayBuffers where each buffer represents
 * a binary frame ready to be sent via udp
 * @param frameOptions
 * @return ArrayBuffer
 */
export const getFrame = frameOptions => {
  const options = { ...defaultOptions, ...frameOptions }
  const payload = options.payload
  const bufferView = new DataView(payload, 0)
  let crc = 0
  for (let i = 0; i < payload.byteLength - 1; i++) {
    crc = crc ^ bufferView.getUint8(i)
  }

  const fragmentedMessages = chunkArrayBuffer(
    payload,
    options.maxPacketSize -
      (GENERAL_HEADER + MESSAGE_HEADER + FIRST_FRAME_HEADER + 1) / 8
  )

  const output = fragmentedMessages.map((message, index) => {
    const isFirstFragment = () => index === 0
    const HEADER_SIZE = isFirstFragment()
      ? GENERAL_HEADER + MESSAGE_HEADER + FIRST_FRAME_HEADER
      : GENERAL_HEADER + MESSAGE_HEADER
    const messageBuffer = new ArrayBuffer(
      message.byteLength + HEADER_SIZE / 8 + 1
    )

    const headerView = new DataView(messageBuffer, 0, HEADER_SIZE / 8)
    headerView.setUint8(0, getHeader(options))
    headerView.setUint8(1, options.message.nodeId)
    headerView.setUint8(2, options.message.session)
    headerView.setUint8(3, frameCount)
    headerView.setUint8(4, index)
    if (isFirstFragment()) {
      headerView.setUint16(5, messageBuffer.byteLength, true)
      headerView.setUint8(7, crc)
    }

    const payloadView = new DataView(
      messageBuffer,
      HEADER_SIZE / 8,
      message.byteLength
    )

    const payloadArray = new Uint8Array(message)
    for (let i = 0; i < payloadArray.length; i++) {
      payloadView.setUint8(i, payloadArray[i])
    }
    return messageBuffer
  })
  frameCount++
  return output
}
